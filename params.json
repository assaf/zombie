{"name":"Zombie","tagline":"Insanely fast, full-stack, headless browser testing using node.js","body":"# Zombie.js\r\n### Insanely fast, headless full-stack testing using Node.js\r\n\r\n[![NPM](https://img.shields.io/npm/v/zombie.svg?style=flat-square&label=latest)](https://www.npmjs.com/package/zombie)\r\n[![Changelog](https://img.shields.io/badge/see-CHANGELOG-red.svg?style=flat-square)](https://github.com/assaf/zombie/blob/master/CHANGELOG.md)\r\n<img width=\"12\" src=\"data:image/gif;base64,R0lGODlhAQABAPAAAP\">\r\n![Node](https://img.shields.io/node/v/zombie.svg?style=flat-square&label=io.js)\r\n[![Travis.ci](https://img.shields.io/travis/assaf/zombie.svg?style=flat-square)](https://travis-ci.org/assaf/zombie)\r\n<img width=\"12\" src=\"data:image/gif;base64,R0lGODlhAQABAPAAAP\">\r\n[![JS.ORG](https://img.shields.io/badge/js.org-zombie-ffb400.svg?style=flat-square)](http://js.org)\r\n\r\n**Zombie 4.x** is tested to work with [io.js 1.6 or later](https://iojs.org/en/index.html).\r\nIf you need to use Node 0.12 or earlier, consider using Zombie 2.x.\r\n\r\n\r\n\r\n## The Bite\r\n\r\nIf you're going to write an insanely fast, headless browser, how can you not\r\ncall it Zombie?  Zombie it is.\r\n\r\nZombie.js is a lightweight framework for testing client-side JavaScript code in\r\na simulated environment.  No browser required.\r\n\r\nLet's try to sign up to a page and see what happens:\r\n\r\n```js\r\nconst Browser = require('zombie');\r\n\r\n// We're going to make requests to http://example.com/signup\r\n// Which will be routed to our test server localhost:3000\r\nBrowser.localhost('example.com', 3000);\r\n\r\ndescribe('User visits signup page', function() {\r\n\r\n  const browser = new Browser();\r\n\r\n  before(function(done) {\r\n    browser.visit('/signup', done);\r\n  });\r\n\r\n  describe('submits form', function() {\r\n\r\n    before(function(done) {\r\n      browser\r\n        .fill('email',    'zombie@underworld.dead')\r\n        .fill('password', 'eat-the-living')\r\n        .pressButton('Sign Me Up!', done);\r\n    });\r\n\r\n    it('should be successful', function() {\r\n      browser.assert.success();\r\n    });\r\n\r\n    it('should see welcome page', function() {\r\n      browser.assert.text('title', 'Welcome To Brains Depot');\r\n    });\r\n  });\r\n});\r\n```\r\n\r\nThis example uses the [Mocha](https://github.com/mochajs/mocha) testing\r\nframework, but Zombie will work with other testing frameworks.  Since Mocha\r\nsupports promises, we can also write the test like this:\r\n\r\n```js\r\nconst Browser = require('zombie');\r\n\r\n// We're going to make requests to http://example.com/signup\r\n// Which will be routed to our test server localhost:3000\r\nBrowser.localhost('example.com', 3000);\r\n\r\ndescribe('User visits signup page', function() {\r\n\r\n  const browser = new Browser();\r\n\r\n  before(function() {\r\n    return browser.visit('/signup');\r\n  });\r\n\r\n  describe('submits form', function() {\r\n\r\n    before(function() {\r\n      browser\r\n        .fill('email',    'zombie@underworld.dead')\r\n        .fill('password', 'eat-the-living');\r\n      return browser.pressButton('Sign Me Up!');\r\n    });\r\n\r\n    it('should be successful', function() {\r\n      browser.assert.success();\r\n    });\r\n\r\n    it('should see welcome page', function() {\r\n      browser.assert.text('title', 'Welcome To Brains Depot');\r\n    });\r\n  });\r\n\r\n});\r\n```\r\n\r\nWell, that was easy.\r\n\r\n\r\n\r\n\r\n## Table of Contents\r\n\r\n* [Installing](#installing)\r\n* [Browser](#browser)\r\n* [Assertions](#assertions)\r\n* [Cookies](#cookies)\r\n* [Tabs](#tabs)\r\n* [Debugging](#debugging)\r\n* [Events](#events)\r\n* [Resources](#resources)\r\n* [Pipeline](#pipeline)\r\n\r\n\r\n\r\n\r\n## Installing\r\n\r\nTo install Zombie.js you will need [io.js](https://iojs.org/):\r\n\r\n```bash\r\n$ npm install zombie --save-dev\r\n```\r\n\r\n\r\n\r\n## Browser\r\n\r\n#### browser.assert\r\n\r\nMethods for making assertions against the browser, such as\r\n`browser.assert.element('.foo')`.\r\n\r\nSee [Assertions](#assertions) for detailed discussion.\r\n\r\n#### browser.referer\r\n\r\nYou can use this to set the HTTP Referer header.\r\n\r\n#### browser.resources\r\n\r\nAccess to history of retrieved resources.  See [Resources](#resources) for\r\ndetailed discussion.\r\n\r\n#### browser.pipeline\r\n\r\nAccess to the pipeline for making requests and processing responses.  Use this\r\nto add new request/response handlers the pipeline for a single browser instance,\r\nor use `Pipeline.addHandler` to modify all instances.  See\r\n[Pipeline](#pipeline).\r\n\r\n\r\n#### browser.tabs\r\n\r\nArray of all open tabs (windows).  Allows you to operate on more than one open\r\nwindow at a time.\r\n\r\nSee [Tabs](#tabs) for detailed discussion.\r\n\r\n#### browser.proxy\r\n\r\nThe `proxy` option takes a URL so you can tell Zombie what protocol, host and\r\nport to use. Also supports Basic authentication, e.g.:\r\n\r\n```js\r\nbrowser.proxy = 'http://me:secret@myproxy:8080'\r\n```\r\n\r\n#### browser.errors\r\n\r\nCollection of errors accumulated by the browser while loading page and executing\r\nscripts.\r\n\r\n#### Browser.localhost(host, port)\r\n\r\nAllows you to make requests against a named domain and HTTP/S port, and will\r\nroute it to the test server running on localhost and unprivileged port.\r\n\r\nFor example, if you want to call your application \"example.com\", and redirect\r\ntraffic from port 80 to the test server that's listening on port 3000, you can\r\ndo this:\r\n\r\n```js\r\nBrowser.localhost('example.com', 3000)\r\nbrowser.visit('/path', function() {\r\n  console.log(browser.location.href);\r\n});\r\n=> 'http://example.com/path'\r\n```\r\n\r\nThe first time you call `Browser.localhost`, if you didn't specify\r\n`Browser.site`, it will set it to the hostname (in the above example,\r\n\"example.com\").  Whenever you call `browser.visit` with a relative URL, it\r\nappends it to `Browser.site`, so you don't need to repeat the full URL in every\r\ntest case.\r\n\r\nYou can use wildcards to map domains and all hosts within these domains, and you\r\ncan specify the source port to map protocols other than HTTP.  For example:\r\n\r\n```js\r\n// HTTP requests for example.test www.example.test will be answered by localhost\r\n// server running on port 3000\r\nBrowser.localhost('*.example.test', 3000);\r\n// HTTPS requests will be answered by localhost server running on port 3001\r\nBrowser.localhost('*.example.test:443', 3001);\r\n```\r\n\r\nThe underlying implementation hacks `net.Socket.connect`, so it will route any\r\nTCP connection made by the Node application, whether Zombie or any other\r\nlibrary.  It does not affect other processes running on your machine.\r\n\r\n### Browser.extend\r\n\r\nYou can use this to customize new browser instances for your specific needs.\r\nThe extension function is called for every new browser instance, and can change\r\nproperties, bind methods, register event listeners, etc.\r\n\r\n```js\r\nBrowser.extend(function(browser) {\r\n  browser.on('console', function(level, message) {\r\n    logger.log(message);\r\n  });\r\n  browser.on('log', function(level, message) {\r\n    logger.log(message);\r\n  });\r\n});\r\n```\r\n\r\n\r\n\r\n\r\n## Assertions\r\n\r\nTo make life easier, Zombie introduces a set of convenience assertions that you\r\ncan access directly from the browser object.  For example, to check that a page\r\nloaded successfully:\r\n\r\n```js\r\nbrowser.assert.success();\r\nbrowser.assert.text('title', 'My Awesome Site');\r\nbrowser.assert.element('#main');\r\n```\r\n\r\nThese assertions are available from the `browser` object since they operate on a\r\nparticular browser instance -- generally dependent on the currently open window,\r\nor document loaded in that window.\r\n\r\nMany assertions require an element/elements as the first argument, for example,\r\nto compare the text content (`assert.text`), or attribute value\r\n(`assert.attribute`).  You can pass one of the following values:\r\n\r\n- An HTML element or an array of HTML elements\r\n- A CSS selector string (e.g. \"h2\", \".book\", \"#first-name\")\r\n\r\nMany assertions take an expected value and compare it against the actual value.\r\nFor example, `assert.text` compares the expected value against the text contents\r\nof one or more strings.  The expected value can be one of:\r\n\r\n- A JavaScript primitive value (string, number)\r\n- `undefined` or `null` are used to assert the lack of value\r\n- A regular expression\r\n- A function that is called with the actual value and returns true if the\r\n  assertion is true\r\n- Any other object will be matched using `assert.deepEqual`\r\n\r\nNote that in some cases the DOM specification indicates that lack of value is an\r\nempty string, not `null`/`undefined`.\r\n\r\nAll assertions take an optional last argument that is the message to show if the\r\nassertion fails.  Better yet, use a testing framework like\r\n[Mocha](https://github.com/mochajs/mocha) that has good diff support and\r\ndon't worry about these messages.\r\n\r\n\r\n### Available Assertions\r\n\r\nThe following assertions are available:\r\n\r\n#### assert.attribute(selection, name, expected, message)\r\n\r\nAsserts the named attribute of the selected element(s) has the expected value.\r\n\r\nFails if no element found.\r\n\r\n```js\r\nbrowser.assert.attribute('form', 'method', 'post');\r\nbrowser.assert.attribute('form', 'action', '/customer/new');\r\n// Disabled with no attribute value, i.e. <button disabled>\r\nbrowser.assert.attribute('button', 'disabled', '');\r\n// No disabled attribute i.e. <button>\r\nbrowser.assert.attribute('button', 'disabled', null);\r\n```\r\n\r\n#### assert.className(selection, className, message)\r\n\r\nAsserts that selected element(s) has that and only that class name.  May also be\r\nspace-separated list of class names.\r\n\r\nFails if no element found.\r\n\r\n```js\r\nbrowser.assert.className('form input[name=email]', 'has-error');\r\n```\r\n\r\n#### assert.cookie(identifier, expected, message)\r\n\r\nAsserts that a cookie exists and  has the expected value, or if `expected` is\r\n`null`, that no such cookie exists.\r\n\r\nThe identifier is either the name of a cookie, or an object with the property\r\n`name` and the optional properties `domain` and `path`.\r\n\r\n```js\r\nbrowser.assert.cookie('flash', 'Missing email address');\r\n```\r\n\r\n#### assert.element(selection, message)\r\n\r\nAsserts that one element matching selection exists.\r\n\r\nFails if no element or more than one matching element are found.\r\n\r\n```js\r\nbrowser.assert.element('form');\r\nbrowser.assert.element('form input[name=email]');\r\nbrowser.assert.element('form input[name=email].has-error');\r\n```\r\n\r\n#### assert.elements(selection, count, message)\r\n\r\nAsserts how many elements exist in the selection.\r\n\r\nThe argument `count` can be a number, or an object with the following\r\nproperties:\r\n\r\n- `atLeast` - Expecting to find at least that many elements\r\n- `atMost`  - Expecting to find at most that many elements\r\n- `exactly` - Expecting to find exactly that many elements\r\n\r\n```js\r\nbrowser.assert.elements('form', 1);\r\nbrowser.assert.elements('form input', 3);\r\nbrowser.assert.elements('form input.has-error', { atLeast: 1 });\r\nbrowser.assert.elements('form input:not(.has-error)', { atMost: 2 });\r\n```\r\n\r\n#### assert.evaluate(expression, expected, message)\r\n\r\nEvaluates the JavaScript expression in the context of the currently open window.\r\n\r\nWith one argument, asserts that the value is equal to `true`.\r\n\r\nWith two/three arguments, asserts that the returned value matches the expected\r\nvalue.\r\n\r\n```js\r\nbrowser.assert.evaluate('$('form').data('valid')');\r\nbrowser.assert.evaluate('$('form').data('errors').length', 3);\r\n```\r\n\r\n#### assert.global(name, expected, message)\r\n\r\nAsserts that the global (window) property has the expected value.\r\n\r\n#### assert.hasClass(selection, className, message)\r\n\r\nAsserts that selected element(s) have the expected class name.  Elements may\r\nhave other class names (unlike `assert.className`).\r\n\r\nFails if no element found.\r\n\r\n```js\r\nbrowser.assert.hasClass('form input[name=email]', 'has-error');\r\n```\r\n\r\n#### assert.hasFocus(selection, message)\r\n\r\nAsserts that selected element has the focus.\r\n\r\nIf the first argument is `null`, asserts that no element has the focus.\r\n\r\nOtherwise, fails if element not found, or if more than one element found.\r\n\r\n```js\r\nbrowser.assert.hasFocus('form input:nth-child(1)');\r\n```\r\n\r\n#### assert.hasNoClass(selection, className, message)\r\n\r\nAsserts that selected element(s) does not have the expected class name.  Elements may\r\nhave other class names (unlike `assert.className`).\r\n\r\nFails if no element found.\r\n\r\n```js\r\nbrowser.assert.hasNoClass('form input', 'has-error');\r\n```\r\n\r\n#### assert.input(selection, expected, message)\r\n\r\nAsserts that selected input field(s) (`input`, `textarea`, `select` etc) have\r\nthe expected value.\r\n\r\nFails if no element found.\r\n\r\n```js\r\nbrowser.assert.input('form input[name=text]', 'Head Eater');\r\n```\r\n\r\n#### assert.link(selection, text, url, message)\r\n\r\nAsserts that at least one link exists with the given selector, text and URL.\r\nThe selector can be `a`, but a more specific selector is recommended.\r\n\r\nURL can be relative to the current document, or a regular expression.\r\n\r\nFails if no element is selected that also has the specified text content and\r\nURL.\r\n\r\n```js\r\nbrowser.assert.link('footer a', 'Privacy Policy', '/privacy');\r\n```\r\n\r\n#### assert.redirected(message)\r\n\r\nAsserts the browser was redirected when retrieving the current page.\r\n\r\n#### assert.success(message)\r\n\r\nAsserts the current page loaded successfully (status code 2xx or 3xx).\r\n\r\n#### assert.status(code, message)\r\n\r\nAsserts the current page loaded with the expected status code.\r\n\r\n```js\r\nbrowser.assert.status(404);\r\n```\r\n\r\n#### assert.style(selection, style, expected, message)\r\n\r\nAsserts that selected element(s) have the expected value for the named style\r\nproperty.  For example:\r\n\r\nFails if no element found, or element style does not match expected value.\r\n\r\n```js\r\nbrowser.assert.style('#show-hide.hidden', 'display', 'none');\r\nbrowser.assert.style('#show-hide:not(.hidden)', 'display', '');\r\n```\r\n\r\n#### assert.text(selection, expected, message)\r\n\r\nAsserts that selected element(s) have the expected text content.  For example:\r\n\r\nFails if no element found that has that text content.\r\n\r\n```js\r\nbrowser.assert.text('title', 'My Awesome Page');\r\n```\r\n\r\n#### assert.url(url, message)\r\n\r\nAsserts the current page has the expected URL.\r\n\r\nThe expected URL can be one of:\r\n\r\n- The full URL as a string\r\n- A regular expression\r\n- A function, called with the URL and returns true if the assertion is true\r\n- An [object](http://nodejs.org/api/url.html#url_url_parse_urlstr_parsequerystring_slashesdenotehost), in which case individual properties are matched against the URL\r\n\r\nFor example:\r\n\r\n```js\r\nbrowser.assert.url('http://localhost/foo/bar');\r\nbrowser.assert.url(new RegExp('^http://localhost/foo/\\\\w+$'));\r\nbrowser.assert.url({ pathname: '/foo/bar' });\r\nbrowser.assert.url({ query: { name: 'joedoe' } });\r\n```\r\n\r\n\r\n### Roll Your Own Assertions\r\n\r\nNot seeing an assertion you want?  You can add your own assertions to the\r\nprototype of `Browser.Assert`.\r\n\r\nFor example:\r\n\r\n```js\r\n// Asserts the browser has the expected number of open tabs.\r\nBrowser.Assert.prototype.openTabs = function(expected, message) {\r\n  assert.equal(this.browser.tabs.length, expected, message);\r\n};\r\n```\r\n\r\nOr application specific:\r\n\r\n```js\r\n// Asserts which links is highlighted in the navigation bar\r\nBrowser.Assert.navigationOn = function(linkText) {\r\n  this.assert.element('.navigation-bar');\r\n  this.assert.text('.navigation-bar a.highlighted', linkText);\r\n};\r\n```\r\n\r\n\r\n\r\n\r\n## Cookies\r\n\r\nAre delicious.  Also, somewhat tricky to work with.   A browser will only send a\r\ncookie to the server if it matches the request domain and path.\r\n\r\nMost modern Web applications don't care so much about the path and set all\r\ncookies to the root path of the application (`/`), but do pay attention to the\r\ndomain.\r\n\r\nConsider this code:\r\n\r\n```js\r\nbrowser.setCookie(name: 'session', domain: 'example.com', value: 'delicious');\r\nbrowser.visit('http://example.com', function() {\r\n  const value = browser.getCookie('session');\r\n  console.log('Cookie', value);\r\n});\r\n```\r\n\r\nIn order for the cookie to be set in this example, we need to specify the cookie\r\nname, domain and path.  In this example we omit the path and choose the default\r\n`/`.\r\n\r\nTo get the cookie in this example, we only need the cookie name, because at that\r\npoint the browser has an open document, and it can use the domain of that\r\ndocument to find the right cookie.  We do need to specify a domain if we're\r\ninterested in other cookies, e.g for a 3rd party widget.\r\n\r\nThere may be multiple cookies that match the same host, for example, cookies set\r\nfor `.example.com` and `www.example.com` will both match `www.example.com`, but\r\nonly the former will match `example.com`.  Likewise, cookies set for `/` and\r\n`/foo` will both match a request for `/foo/bar`.\r\n\r\n`getCookie`, `setCookie` and `deleteCookie` always operate on a single cookie,\r\nand they match the most specific one, starting with the cookies that have the\r\nlongest matching domain, followed by the cookie that has the longest matching\r\npath.\r\n\r\nIf the first argument is a string, they look for a cookie with that name using\r\nthe hostname of the currently open page as the domain and `/` as the path.  To\r\nbe more specific, the first argument can be an object with the properties\r\n`name`, `domain` and `path`.\r\n\r\nThe following are equivalent:\r\n\r\n```js\r\nbrowser.getCookie('session');\r\nbrowser.getCookie({ name: 'session',\r\n                    domain: browser.location.hostname,\r\n                    path: browser.location.pathname });\r\n```\r\n\r\n\r\n`getCookie` take a second argument.  If false (or missing), it returns the\r\nvalue of the cookie.  If true, it returns an object with all the cookie\r\nproperties: `name`, `value`, `domain`, `path`, `expires`, `httpOnly` and\r\n`secure`.\r\n\r\n#### browser.cookies\r\n\r\nReturns an object holding all cookies used by this browser.\r\n\r\n#### browser.cookies.dump(output?)\r\n\r\nDumps all cookies to standard output, or the output stream.\r\n\r\n#### browser.deleteCookie(identifier)\r\n\r\nDeletes a cookie matching the identifier.\r\n\r\nThe identifier is either the name of a cookie, or an object with the property\r\n`name` and the optional properties `domain` and `path`.\r\n\r\n#### browser.deleteCookies()\r\n\r\nDeletes all cookies.\r\n\r\n#### browser.getCookie(identifier, allProperties?)\r\n\r\nReturns a cookie matching the identifier.\r\n\r\nThe identifier is either the name of a cookie, or an object with the property\r\n`name` and the optional properties `domain` and `path`.\r\n\r\nIf `allProperties` is true, returns an object with all the cookie properties,\r\notherwise returns the cookie value.\r\n\r\n#### browser.setCookie(name, value)\r\n\r\nSets the value of a cookie based on its name.\r\n\r\n#### browser.setCookie(cookie)\r\n\r\nSets the value of a cookie based on the following properties:\r\n\r\n* `domain` - Domain of the cookie (requires, defaults to hostname of currently\r\n  open page)\r\n* `expires` - When cookie it set to expire (`Date`, optional, defaults to\r\n  session)\r\n* `maxAge` - How long before cookie expires (in seconds, defaults to session)\r\n* `name` - Cookie name (required)\r\n* `path` - Path for the cookie (defaults to `/`)\r\n* `httpOnly` - True if HTTP-only (not accessible from client-side JavaScript,\r\n  defaults to false)\r\n* `secure` - True if secure (requires HTTPS, defaults to false)\r\n* `value` - Cookie value (required)\r\n\r\n\r\n\r\n\r\n## Tabs\r\n\r\nJust like your favorite Web browser, Zombie manages multiple open windows as\r\ntabs.  New browsers start without any open tabs.  As you visit the first page,\r\nZombie will open a tab for it.\r\n\r\nAll operations against the `browser` object operate on the currently active tab\r\n(window) and most of the time you only need to interact with that one tab.  You\r\ncan access it directly via `browser.window`.\r\n\r\nWeb pages can open additional tabs using the `window.open` method, or whenever a\r\nlink or form specifies a target (e.g. `target=_blank` or `target=window-name`).\r\nYou can also open additional tabs by calling `browser.open`.  To close the\r\ncurrently active tab, close the window itself.\r\n\r\nYou can access all open tabs from `browser.tabs`.  This property is an\r\nassociative array, you can access each tab by its index number, and iterate over\r\nall open tabs using functions like `forEach` and `map`.\r\n\r\nIf a window was opened with a name, you can also access it by its name.  Since\r\nnames may conflict with reserved properties/methods, you may need to use\r\n`browser.tabs.find`.\r\n\r\nThe value of a tab is the currently active window.  That window changes when you\r\nnavigate forwards and backwards in history.  For example, if you visited the URL\r\n'/foo' and then the URL '/bar', the first tab (`browser.tabs[0]`) would be a\r\nwindow with the document from '/bar'.  If you then navigate back in history, the\r\nfirst tab would be the window with the document '/foo'.\r\n\r\nThe following operations are used for managing tabs:\r\n\r\n#### browser.tabs\r\n\r\nReturns an array of all open tabs.\r\n\r\n#### browser.tabs[number]\r\n\r\nReturns the tab with that index number.\r\n\r\n#### browser.tabs[string]\r\n#### browser.tabs.find(string)\r\n\r\nReturns the tab with that name.\r\n\r\n#### browser.tabs.closeAll()\r\n\r\nCloses all tabs.\r\n\r\n#### browser.tabs.current\r\n\r\nThis is a read/write property.  It returns the currently active tab.\r\n\r\nCan also be used to change the currently active tab.  You can set it to a\r\nwindow (e.g. as currently returned from `browser.current`), a window name or the\r\ntab index number.\r\n\r\n#### browser.tabs.dump(output?)\r\n\r\nDump a list of all open tabs to standard output, or the output stream.\r\n\r\n#### browser.tabs.index\r\n\r\nReturns the index of the currently active tab.\r\n\r\n#### browser.tabs.length\r\n\r\nReturns the number of currently opened tabs.\r\n\r\n#### browser.open (url)\r\n\r\nOpens and returns a new tab.  Supported options are:\r\n- `name` - Window name.\r\n- `url` - Load document from this URL.\r\n\r\n#### browser.window\r\n\r\nReturns the currently active window, same as `browser.tabs.current.`\r\n\r\n\r\n\r\n\r\n## Debugging\r\n\r\nTo see what your code is doing, you can use `console.log` and friends from both\r\nclient-side scripts and your test code.\r\n\r\nTo see everything Zombie does (opening windows, loading URLs, firing events,\r\netc), set the environment variable `DEBUG=zombie`.  Zombie uses the\r\n[debug](https://github.com/visionmedia/debug) module.  For example:\r\n\r\n```bash\r\n$ DEBUG=zombie mocha\r\n```\r\n\r\nYou can also turn debugging on from your code (e.g. a specific test you're\r\ntrying to troubleshoot) by calling `browser.debug()`.\r\n\r\nSome objects, like the browser, history, resources, tabs and windows also\r\ninclude `dump` method that will dump the current state to the console, or an\r\noutput stream of your choice.  For example:\r\n\r\n```js\r\nbrowser.dump();\r\nbrowser.dump(process.stderr);\r\n```\r\n\r\nIf you want to disable console output from scripts, set `browser.silent = true`\r\nor once for all browser instances with `Browser.silent = true`.\r\n\r\n\r\n\r\n\r\n## Events\r\n\r\nEach browser instance is an `EventEmitter`, and will emit a variety of events\r\nyou can listen to.\r\n\r\nSome things you can do with events:\r\n\r\n- Trace what the browser is doing, e.g. log every page loaded, every DOM event\r\n  emitted, every timeout fired\r\n- Wait for something to happen, e.g. form submitted, link clicked, input element\r\n  getting the focus\r\n- Strip out code from HTML pages, e.g remove analytics code when running tests\r\n- Add event listeners to the page before any JavaScript executes\r\n- Mess with the browser, e.g. modify loaded resources, capture and change DOM\r\n  events\r\n\r\n#### console (level, message)\r\n\r\nEmitted whenever a message is printed to the console (`console.log`,\r\n`console.error`, `console.trace`, etc).\r\n\r\nThe first argument is the logging level, and the second argument is the message.\r\n\r\nThe logging levels are: `debug`, `error`, `info`, `log`, `trace` and `warn`.\r\n\r\n#### active (window)\r\n\r\nEmitted when this window becomes the active window.\r\n\r\n#### closed (window)\r\n\r\nEmitted when this window is closed.\r\n\r\n#### done ()\r\n\r\nEmitted when the event loop goes empty.\r\n\r\n#### error (error)\r\n\r\nError when loading a resource, or evaluating JavaScript.\r\n\r\n#### evaluated (code, result, filename)\r\n\r\nEmitted after JavaScript code is evaluated.\r\n\r\nThe first argument is the JavaScript function or code (string).  The second\r\nargument is the result.  The third argument is the filename.\r\n\r\n#### event (event, target)\r\n\r\nEmitted whenever a DOM event is fired on the target element, document or window.\r\n\r\n#### focus (element)\r\n\r\nEmitted whenever an element receives the focus.\r\n\r\n#### idle ()\r\n\r\nEvent loop is idle.\r\n\r\n#### inactive (window)\r\n\r\nEmitted when this window is no longer the active window.\r\n\r\n#### interval (function, interval)\r\n\r\nEmitted whenever an interval (`setInterval`) is fired.\r\n\r\nThe first argument is the function or code to evaluate, the second argument is\r\nthe interval in milliseconds.\r\n\r\n#### link (url, target)\r\n\r\nEmitted when a link is clicked.\r\n\r\nThe first argument is the URL of the new location, the second argument\r\nidentifies the target window (`_self`, `_blank`, window name, etc).\r\n\r\n#### loaded (document)\r\n\r\nEmitted when a document has been loaded into a window or frame.\r\n\r\nThis event is emitted after the HTML is parsed, and some scripts executed.\r\n\r\n#### loading (document)\r\n\r\nEmitted when a document is about to be loaded into a window or frame.\r\n\r\nThis event is emitted when the document is still empty, before parsing any HTML.\r\n\r\n#### opened (window)\r\n\r\nEmitted when a new window is opened.\r\n\r\n#### redirect (request, response)\r\n\r\nEmitted when following a redirect.\r\n\r\n#### request (request)\r\n\r\nEmitted before making a request to retrieve a resource.\r\n\r\nThe first argument is the request object.  See [Resources](#resources) for more\r\ndetails.\r\n\r\n#### response (request, response)\r\n\r\nEmitted after receiving the response (excluding redirects).\r\n\r\nThe first argument is the request object, the second argument is the response\r\nobject.  See [Resources](#resources) for more details.\r\n\r\n#### serverEvent ()\r\n\r\nBrowser received server initiated event (e.g. `EventSource` message).\r\n\r\n#### setInterval (function, interval)\r\n\r\nEvent loop fired a `setInterval` event.\r\n\r\n#### setTimeout (function, delay)\r\n\r\nEvent loop fired a `setTimeout` event.\r\n\r\n#### submit (url, target)\r\n\r\nEmitted whenever a form is submitted.\r\n\r\nThe first argument is the URL of the new location, the second argument\r\nidentifies the target window (`_self`, `_blank`, window name, etc).\r\n\r\n#### timeout (function, delay)\r\n\r\nEmitted whenever a timeout (`setTimeout`) is fired.\r\n\r\nThe first argument is the function or code to evaluate, the second argument is\r\nthe delay in milliseconds.\r\n\r\n#### xhr (event, url)\r\n\r\nCalled for each XHR event (`progress`, `abort`, `readystatechange`, `loadend`,\r\netc).\r\n\r\n\r\n\r\n\r\n## Resources\r\n\r\nZombie can retrieve with resources - HTML pages, scripts, XHR requests - over\r\nHTTP, HTTPS and from the file system.\r\n\r\nMost work involving resources is done behind the scenes, but there are few\r\nnotable features that you'll want to know about. Specifically, if you need to do\r\nany of the following:\r\n\r\n- Inspect the history of retrieved resources, useful for troubleshooting issues\r\n  related to resource loading\r\n- Request resources directly, but have Zombie handle cookies, authentication,\r\n  etc\r\n- Implement new mechanism for retrieving resources, for example, add new\r\n  protocols or support new headers (see [Pipeline](#pipeline))\r\n\r\n\r\n### The Resources List\r\n\r\nEach browser provides access to the list of resources loaded by the currently\r\nopen window via `browser.resources`.  You can iterate over this list just like\r\nany JavaScript array.\r\n\r\nEach resource provides three properties:\r\n\r\n- `request`   - The request object\r\n- `response`  - The resource object (if received)\r\n- `error`     - The error generated (no response)\r\n\r\nThe request object is based on the [Fetch API Request\r\nobject](https://fetch.spec.whatwg.org/#request-class).\r\n\r\nThe response object is based on the [Fetch API Response\r\nobject](https://fetch.spec.whatwg.org/#response-class).  Note that the fetch API\r\nhas the property `status`, whereas Node HTTP module uses `statusCode`.\r\n\r\n#### browser.fetch(input, init)\r\n\r\nYou can use the browser directly to make requests against external resources.\r\nThese requests will share the same cookies, authentication and other browser\r\nsettings (also pipline).\r\n\r\nThe `fetch` method is based on the [Fetch\r\nAPI](https://fetch.spec.whatwg.org/#fetch-method).\r\n\r\nFor example:\r\n\r\n```\r\nbrowser.fetch(url)\r\n  .then(function(response) {\r\n    console.log('Status code:', response.status);\r\n    if (response.status === 200)\r\n      return response.text();\r\n  })\r\n  .then(function(text) {\r\n    console.log('Document:', text);\r\n  })\r\n  .catch(function(error) {\r\n    console.log('Network error');\r\n  });\r\n```\r\n\r\nTo access the response document body as a Node buffer, use the following:\r\n\r\n```js\r\nresponse.arrayBuffer()\r\n  .then(Buffer) // arrayBuffer -> Buffer\r\n  .then(function(buffer) {\r\n    assert( Buffer.isBuffer(buffer) );\r\n  });\r\n```\r\n\r\n#### resources.dump(output?)\r\n\r\nDumps the resources list to the output stream (defaults to standard output\r\nstream).\r\n\r\n\r\n\r\n\r\n## Pipeline\r\n\r\nZombie uses a pipeline to operate on resources.  You can extend that pipeline\r\nwith your own set of handlers, for example, to support additional protocols,\r\ncontent types, special handlers, etc.\r\n\r\nThe pipeline consists of a set of handlers.  There are two types of handlers:\r\n\r\nFunctions with two arguments deal with requests.  They are called with the\r\nbrowser and request object.  They may modify the request object, and they may\r\neither return null (pass control to the next handler) or return the Response\r\nobject, or return a promise that resolves to either outcome.\r\n\r\nFunctions with three arguments deal with responses.  They are called with the\r\nbrowser, request and response objects.  They may modify the response object, and\r\nmust return a Response object, either the same as the argument or a new Response\r\nobject, either directly or through a promise.\r\n\r\nTo add a new handle to the end of the pipeline:\r\n\r\n```js\r\nbrowser.pipeline.addHandler(function(browser, request) {\r\n  // Let's delay this request by 1/10th second\r\n  return new Promise(function(resolve) {\r\n    setTimeout(resolve, 100);\r\n  });\r\n});\r\n```\r\n\r\nYou can add handlers to all browsers via `Pipeline.addHandler`.  These\r\nhandlers are automatically added to every new `browser.pipeline` instance.\r\n\r\n```js\r\nPipeline.addHandler(function(browser, request, response) {\r\n  // Log the response body\r\n  console.log('Response body: ' + response.body);\r\n});\r\n```\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}